// Disjoint Set :-

***************************************************************************** Disjoint set
#include <bits/stdc++.h>
using namespace std;
class DisjointSet {
    vector<int> rank, parent, size; 
public: 
    DisjointSet(int n) {
        rank.resize(n+1, 0); 
        parent.resize(n+1);
        size.resize(n+1); 
        for(int i = 0;i<=n;i++) {
            parent[i] = i; 
            size[i] = 1; 
        }
    }

    int findUPar(int node) {
        if(node == parent[node])
            return node; 
        return parent[node] = findUPar(parent[node]); 
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u); 
        int ulp_v = findUPar(v); 
        if(ulp_u == ulp_v) return; 
        if(rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v; 
        }
        else if(rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u; 
        }
        else {
            parent[ulp_v] = ulp_u; 
            rank[ulp_u]++; 
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u); 
        int ulp_v = findUPar(v); 
        if(ulp_u == ulp_v) return; 
        if(size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v; 
            size[ulp_v] += size[ulp_u]; 
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v]; 
        }
    }
}; 
int main() {
    DisjointSet ds(7);
    ds.unionBySize(1, 2); 
    ds.unionBySize(2, 3); 
    ds.unionBySize(4, 5); 
    ds.unionBySize(6, 7); 
    ds.unionBySize(5, 6); 
    // if 3 and 7 same or not 
    if(ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n"; 
    }
    else cout << "Not same\n"; 

    ds.unionBySize(3, 7); 

    if(ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n"; 
    }
    else cout << "Not same\n"; 
	return 0;
}
******************************************************************************************************************************** Disjoint set






*************************************************** -> TRIES
#include <bits/stdc++.h> 
class Node{
    Node* links[26] ;
    int cntendwith = 0 ;
    int cntprefix = 0 ;

   public:
    // to check if the trie is present or not ;
    bool containkey(char ch){
        return (links[ch-'a']!=NULL); 
    }
    // to create the reference trie; 
    void put(char ch , Node*node){
        links[ch-'a'] = node; 
    }
    // to get the next node for the traversal if it exists
    Node*get(char ch){
        return links[ch-'a']; 
    }
    void increaseend(){
        cntendwith++; 
    }
    void increaseprefix(){
        cntprefix++ ;
    }
    void deleteend(){
        cntendwith--; 
    }
    void reduceprefix(){
        cntprefix--; 
    }
    int getend(){
        return cntendwith; 
    }
    int getprefix(){
        return cntprefix; 
    }
}; 
class Trie{
     Node*root; 
    public:

    Trie(){
        // Write your code here.
        root = new Node(); 
    }

    void insert(string &word){
        // Write your code here.
        Node*node = root ;
        for(int i = 0 ;i<word.size(); i++){
              if(!node->containkey(word[i])){
                   node->put(word[i], new Node()); // a new reference node will be put in the node
              }
              node = node->get(word[i]); // we put across that word, now we will go to that word
              node->increaseprefix(); 
        }
        node->increaseend() ;
    }

    int countWordsEqualTo(string &word){
        // Write your code here.
        Node*node = root ;
        for(int i = 0 ;i<word.size(); i++){
            if(!node->containkey(word[i]))return 0; 
            node = node->get(word[i]); 
        }
        return node->getend(); 
    }

    int countWordsStartingWith(string &word){
        // Write your code here.
        Node*node = root; 
        for(int i = 0 ;i<word.size(); i++){
            if(!node->containkey(word[i]))return 0; 
            node = node->get(word[i]); 
        }
        return node->getprefix(); 
    }

    void erase(string &word){
        // Write your code here.
        Node*node = root; 
        for(int i = 0 ;i<word.size(); i++){
            if(!node->containkey(word[i]))return ;
            node = node->get(word[i]) ;
            node->reduceprefix() ; 
        }
        node->deleteend(); 
    }
};
**********************************************************************************  <- TRIES


